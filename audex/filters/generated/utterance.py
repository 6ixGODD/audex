# This file is auto-generated by PrototypeX filter generator.
# Do not edit manually - changes will be overwritten.
# Regenerate using: python -m scripts.gen_filters gen

from __future__ import annotations

import datetime
import typing as t

from audex.entity.utterance import Utterance
from audex.filters import FieldFilter
from audex.filters import Filter
from audex.filters import FilterBuilder
from audex.filters import StringBackedFieldFilter
from audex.filters import StringFieldFilter
from audex.valueobj.utterance import Speaker


class UtteranceFilterBuilder(FilterBuilder[Utterance]):
    """Utterance filter builder with full type hints and IDE support.

    This class is auto-generated. Do not edit manually.
    """

    class _IdField(StringFieldFilter):
        """Chainable id filter with type-safe operations."""

        def __init__(self, builder: UtteranceFilterBuilder) -> None:
            super().__init__("id", object.__getattribute__(builder, "_filter"))
            self._parent_builder = builder

        def eq(self, value: str) -> UtteranceFilterBuilder:
            super().eq(value)
            return self._parent_builder

        def ne(self, value: str) -> UtteranceFilterBuilder:
            super().ne(value)
            return self._parent_builder

        def gt(self, value: str) -> UtteranceFilterBuilder:
            super().gt(value)
            return self._parent_builder

        def lt(self, value: str) -> UtteranceFilterBuilder:
            super().lt(value)
            return self._parent_builder

        def gte(self, value: str) -> UtteranceFilterBuilder:
            super().gte(value)
            return self._parent_builder

        def lte(self, value: str) -> UtteranceFilterBuilder:
            super().lte(value)
            return self._parent_builder

        def in_(self, values: t.Sequence[str]) -> UtteranceFilterBuilder:
            super().in_(values)
            return self._parent_builder

        def nin(self, values: t.Sequence[str]) -> UtteranceFilterBuilder:
            super().nin(values)
            return self._parent_builder

        def between(self, value1: str, value2: str) -> UtteranceFilterBuilder:
            super().between(value1, value2)
            return self._parent_builder

        def is_null(self) -> UtteranceFilterBuilder:
            super().is_null()
            return self._parent_builder

        def is_not_null(self) -> UtteranceFilterBuilder:
            super().is_not_null()
            return self._parent_builder

        def asc(self) -> UtteranceFilterBuilder:
            super().asc()
            return self._parent_builder

        def desc(self) -> UtteranceFilterBuilder:
            super().desc()
            return self._parent_builder

        def contains(self, value: str) -> UtteranceFilterBuilder:
            super().contains(value)
            return self._parent_builder

        def startswith(self, value: str) -> UtteranceFilterBuilder:
            super().startswith(value)
            return self._parent_builder

        def endswith(self, value: str) -> UtteranceFilterBuilder:
            super().endswith(value)
            return self._parent_builder

    class _CreatedAtField(FieldFilter[datetime.datetime]):
        """Chainable created_at filter with type-safe operations."""

        def __init__(self, builder: UtteranceFilterBuilder) -> None:
            super().__init__("created_at", object.__getattribute__(builder, "_filter"))
            self._parent_builder = builder

        def eq(self, value: datetime.datetime) -> UtteranceFilterBuilder:
            super().eq(value)
            return self._parent_builder

        def ne(self, value: datetime.datetime) -> UtteranceFilterBuilder:
            super().ne(value)
            return self._parent_builder

        def gt(self, value: datetime.datetime) -> UtteranceFilterBuilder:
            super().gt(value)
            return self._parent_builder

        def lt(self, value: datetime.datetime) -> UtteranceFilterBuilder:
            super().lt(value)
            return self._parent_builder

        def gte(self, value: datetime.datetime) -> UtteranceFilterBuilder:
            super().gte(value)
            return self._parent_builder

        def lte(self, value: datetime.datetime) -> UtteranceFilterBuilder:
            super().lte(value)
            return self._parent_builder

        def in_(self, values: t.Sequence[datetime.datetime]) -> UtteranceFilterBuilder:
            super().in_(values)
            return self._parent_builder

        def nin(self, values: t.Sequence[datetime.datetime]) -> UtteranceFilterBuilder:
            super().nin(values)
            return self._parent_builder

        def between(
            self, value1: datetime.datetime, value2: datetime.datetime
        ) -> UtteranceFilterBuilder:
            super().between(value1, value2)
            return self._parent_builder

        def is_null(self) -> UtteranceFilterBuilder:
            super().is_null()
            return self._parent_builder

        def is_not_null(self) -> UtteranceFilterBuilder:
            super().is_not_null()
            return self._parent_builder

        def asc(self) -> UtteranceFilterBuilder:
            super().asc()
            return self._parent_builder

        def desc(self) -> UtteranceFilterBuilder:
            super().desc()
            return self._parent_builder

    class _UpdatedAtField(FieldFilter[datetime.datetime | None]):
        """Chainable updated_at filter with type-safe operations."""

        def __init__(self, builder: UtteranceFilterBuilder) -> None:
            super().__init__("updated_at", object.__getattribute__(builder, "_filter"))
            self._parent_builder = builder

        def eq(self, value: datetime.datetime | None) -> UtteranceFilterBuilder:
            super().eq(value)
            return self._parent_builder

        def ne(self, value: datetime.datetime | None) -> UtteranceFilterBuilder:
            super().ne(value)
            return self._parent_builder

        def gt(self, value: datetime.datetime | None) -> UtteranceFilterBuilder:
            super().gt(value)
            return self._parent_builder

        def lt(self, value: datetime.datetime | None) -> UtteranceFilterBuilder:
            super().lt(value)
            return self._parent_builder

        def gte(self, value: datetime.datetime | None) -> UtteranceFilterBuilder:
            super().gte(value)
            return self._parent_builder

        def lte(self, value: datetime.datetime | None) -> UtteranceFilterBuilder:
            super().lte(value)
            return self._parent_builder

        def in_(self, values: t.Sequence[datetime.datetime | None]) -> UtteranceFilterBuilder:
            super().in_(values)
            return self._parent_builder

        def nin(self, values: t.Sequence[datetime.datetime | None]) -> UtteranceFilterBuilder:
            super().nin(values)
            return self._parent_builder

        def between(
            self, value1: datetime.datetime | None, value2: datetime.datetime | None
        ) -> UtteranceFilterBuilder:
            super().between(value1, value2)
            return self._parent_builder

        def is_null(self) -> UtteranceFilterBuilder:
            super().is_null()
            return self._parent_builder

        def is_not_null(self) -> UtteranceFilterBuilder:
            super().is_not_null()
            return self._parent_builder

        def asc(self) -> UtteranceFilterBuilder:
            super().asc()
            return self._parent_builder

        def desc(self) -> UtteranceFilterBuilder:
            super().desc()
            return self._parent_builder

    class _SessionIdField(StringFieldFilter):
        """Chainable session_id filter with type-safe operations."""

        def __init__(self, builder: UtteranceFilterBuilder) -> None:
            super().__init__("session_id", object.__getattribute__(builder, "_filter"))
            self._parent_builder = builder

        def eq(self, value: str) -> UtteranceFilterBuilder:
            super().eq(value)
            return self._parent_builder

        def ne(self, value: str) -> UtteranceFilterBuilder:
            super().ne(value)
            return self._parent_builder

        def gt(self, value: str) -> UtteranceFilterBuilder:
            super().gt(value)
            return self._parent_builder

        def lt(self, value: str) -> UtteranceFilterBuilder:
            super().lt(value)
            return self._parent_builder

        def gte(self, value: str) -> UtteranceFilterBuilder:
            super().gte(value)
            return self._parent_builder

        def lte(self, value: str) -> UtteranceFilterBuilder:
            super().lte(value)
            return self._parent_builder

        def in_(self, values: t.Sequence[str]) -> UtteranceFilterBuilder:
            super().in_(values)
            return self._parent_builder

        def nin(self, values: t.Sequence[str]) -> UtteranceFilterBuilder:
            super().nin(values)
            return self._parent_builder

        def between(self, value1: str, value2: str) -> UtteranceFilterBuilder:
            super().between(value1, value2)
            return self._parent_builder

        def is_null(self) -> UtteranceFilterBuilder:
            super().is_null()
            return self._parent_builder

        def is_not_null(self) -> UtteranceFilterBuilder:
            super().is_not_null()
            return self._parent_builder

        def asc(self) -> UtteranceFilterBuilder:
            super().asc()
            return self._parent_builder

        def desc(self) -> UtteranceFilterBuilder:
            super().desc()
            return self._parent_builder

        def contains(self, value: str) -> UtteranceFilterBuilder:
            super().contains(value)
            return self._parent_builder

        def startswith(self, value: str) -> UtteranceFilterBuilder:
            super().startswith(value)
            return self._parent_builder

        def endswith(self, value: str) -> UtteranceFilterBuilder:
            super().endswith(value)
            return self._parent_builder

    class _SegmentIdField(StringFieldFilter):
        """Chainable segment_id filter with type-safe operations."""

        def __init__(self, builder: UtteranceFilterBuilder) -> None:
            super().__init__("segment_id", object.__getattribute__(builder, "_filter"))
            self._parent_builder = builder

        def eq(self, value: str) -> UtteranceFilterBuilder:
            super().eq(value)
            return self._parent_builder

        def ne(self, value: str) -> UtteranceFilterBuilder:
            super().ne(value)
            return self._parent_builder

        def gt(self, value: str) -> UtteranceFilterBuilder:
            super().gt(value)
            return self._parent_builder

        def lt(self, value: str) -> UtteranceFilterBuilder:
            super().lt(value)
            return self._parent_builder

        def gte(self, value: str) -> UtteranceFilterBuilder:
            super().gte(value)
            return self._parent_builder

        def lte(self, value: str) -> UtteranceFilterBuilder:
            super().lte(value)
            return self._parent_builder

        def in_(self, values: t.Sequence[str]) -> UtteranceFilterBuilder:
            super().in_(values)
            return self._parent_builder

        def nin(self, values: t.Sequence[str]) -> UtteranceFilterBuilder:
            super().nin(values)
            return self._parent_builder

        def between(self, value1: str, value2: str) -> UtteranceFilterBuilder:
            super().between(value1, value2)
            return self._parent_builder

        def is_null(self) -> UtteranceFilterBuilder:
            super().is_null()
            return self._parent_builder

        def is_not_null(self) -> UtteranceFilterBuilder:
            super().is_not_null()
            return self._parent_builder

        def asc(self) -> UtteranceFilterBuilder:
            super().asc()
            return self._parent_builder

        def desc(self) -> UtteranceFilterBuilder:
            super().desc()
            return self._parent_builder

        def contains(self, value: str) -> UtteranceFilterBuilder:
            super().contains(value)
            return self._parent_builder

        def startswith(self, value: str) -> UtteranceFilterBuilder:
            super().startswith(value)
            return self._parent_builder

        def endswith(self, value: str) -> UtteranceFilterBuilder:
            super().endswith(value)
            return self._parent_builder

    class _SequenceField(FieldFilter[int]):
        """Chainable sequence filter with type-safe operations."""

        def __init__(self, builder: UtteranceFilterBuilder) -> None:
            super().__init__("sequence", object.__getattribute__(builder, "_filter"))
            self._parent_builder = builder

        def eq(self, value: int) -> UtteranceFilterBuilder:
            super().eq(value)
            return self._parent_builder

        def ne(self, value: int) -> UtteranceFilterBuilder:
            super().ne(value)
            return self._parent_builder

        def gt(self, value: int) -> UtteranceFilterBuilder:
            super().gt(value)
            return self._parent_builder

        def lt(self, value: int) -> UtteranceFilterBuilder:
            super().lt(value)
            return self._parent_builder

        def gte(self, value: int) -> UtteranceFilterBuilder:
            super().gte(value)
            return self._parent_builder

        def lte(self, value: int) -> UtteranceFilterBuilder:
            super().lte(value)
            return self._parent_builder

        def in_(self, values: t.Sequence[int]) -> UtteranceFilterBuilder:
            super().in_(values)
            return self._parent_builder

        def nin(self, values: t.Sequence[int]) -> UtteranceFilterBuilder:
            super().nin(values)
            return self._parent_builder

        def between(self, value1: int, value2: int) -> UtteranceFilterBuilder:
            super().between(value1, value2)
            return self._parent_builder

        def is_null(self) -> UtteranceFilterBuilder:
            super().is_null()
            return self._parent_builder

        def is_not_null(self) -> UtteranceFilterBuilder:
            super().is_not_null()
            return self._parent_builder

        def asc(self) -> UtteranceFilterBuilder:
            super().asc()
            return self._parent_builder

        def desc(self) -> UtteranceFilterBuilder:
            super().desc()
            return self._parent_builder

    class _SpeakerField(StringBackedFieldFilter[Speaker]):
        """Chainable speaker filter with type-safe operations."""

        def __init__(self, builder: UtteranceFilterBuilder) -> None:
            super().__init__("speaker", object.__getattribute__(builder, "_filter"))
            self._parent_builder = builder

        def eq(self, value: Speaker) -> UtteranceFilterBuilder:
            super().eq(value)
            return self._parent_builder

        def ne(self, value: Speaker) -> UtteranceFilterBuilder:
            super().ne(value)
            return self._parent_builder

        def gt(self, value: Speaker) -> UtteranceFilterBuilder:
            super().gt(value)
            return self._parent_builder

        def lt(self, value: Speaker) -> UtteranceFilterBuilder:
            super().lt(value)
            return self._parent_builder

        def gte(self, value: Speaker) -> UtteranceFilterBuilder:
            super().gte(value)
            return self._parent_builder

        def lte(self, value: Speaker) -> UtteranceFilterBuilder:
            super().lte(value)
            return self._parent_builder

        def in_(self, values: t.Sequence[Speaker]) -> UtteranceFilterBuilder:
            super().in_(values)
            return self._parent_builder

        def nin(self, values: t.Sequence[Speaker]) -> UtteranceFilterBuilder:
            super().nin(values)
            return self._parent_builder

        def between(self, value1: Speaker, value2: Speaker) -> UtteranceFilterBuilder:
            super().between(value1, value2)
            return self._parent_builder

        def is_null(self) -> UtteranceFilterBuilder:
            super().is_null()
            return self._parent_builder

        def is_not_null(self) -> UtteranceFilterBuilder:
            super().is_not_null()
            return self._parent_builder

        def asc(self) -> UtteranceFilterBuilder:
            super().asc()
            return self._parent_builder

        def desc(self) -> UtteranceFilterBuilder:
            super().desc()
            return self._parent_builder

        def contains(self, value: str) -> UtteranceFilterBuilder:
            super().contains(value)
            return self._parent_builder

        def startswith(self, value: str) -> UtteranceFilterBuilder:
            super().startswith(value)
            return self._parent_builder

        def endswith(self, value: str) -> UtteranceFilterBuilder:
            super().endswith(value)
            return self._parent_builder

    class _TextField(StringFieldFilter):
        """Chainable text filter with type-safe operations."""

        def __init__(self, builder: UtteranceFilterBuilder) -> None:
            super().__init__("text", object.__getattribute__(builder, "_filter"))
            self._parent_builder = builder

        def eq(self, value: str) -> UtteranceFilterBuilder:
            super().eq(value)
            return self._parent_builder

        def ne(self, value: str) -> UtteranceFilterBuilder:
            super().ne(value)
            return self._parent_builder

        def gt(self, value: str) -> UtteranceFilterBuilder:
            super().gt(value)
            return self._parent_builder

        def lt(self, value: str) -> UtteranceFilterBuilder:
            super().lt(value)
            return self._parent_builder

        def gte(self, value: str) -> UtteranceFilterBuilder:
            super().gte(value)
            return self._parent_builder

        def lte(self, value: str) -> UtteranceFilterBuilder:
            super().lte(value)
            return self._parent_builder

        def in_(self, values: t.Sequence[str]) -> UtteranceFilterBuilder:
            super().in_(values)
            return self._parent_builder

        def nin(self, values: t.Sequence[str]) -> UtteranceFilterBuilder:
            super().nin(values)
            return self._parent_builder

        def between(self, value1: str, value2: str) -> UtteranceFilterBuilder:
            super().between(value1, value2)
            return self._parent_builder

        def is_null(self) -> UtteranceFilterBuilder:
            super().is_null()
            return self._parent_builder

        def is_not_null(self) -> UtteranceFilterBuilder:
            super().is_not_null()
            return self._parent_builder

        def asc(self) -> UtteranceFilterBuilder:
            super().asc()
            return self._parent_builder

        def desc(self) -> UtteranceFilterBuilder:
            super().desc()
            return self._parent_builder

        def contains(self, value: str) -> UtteranceFilterBuilder:
            super().contains(value)
            return self._parent_builder

        def startswith(self, value: str) -> UtteranceFilterBuilder:
            super().startswith(value)
            return self._parent_builder

        def endswith(self, value: str) -> UtteranceFilterBuilder:
            super().endswith(value)
            return self._parent_builder

    class _ConfidenceField(FieldFilter[float | None]):
        """Chainable confidence filter with type-safe operations."""

        def __init__(self, builder: UtteranceFilterBuilder) -> None:
            super().__init__("confidence", object.__getattribute__(builder, "_filter"))
            self._parent_builder = builder

        def eq(self, value: float | None) -> UtteranceFilterBuilder:
            super().eq(value)
            return self._parent_builder

        def ne(self, value: float | None) -> UtteranceFilterBuilder:
            super().ne(value)
            return self._parent_builder

        def gt(self, value: float | None) -> UtteranceFilterBuilder:
            super().gt(value)
            return self._parent_builder

        def lt(self, value: float | None) -> UtteranceFilterBuilder:
            super().lt(value)
            return self._parent_builder

        def gte(self, value: float | None) -> UtteranceFilterBuilder:
            super().gte(value)
            return self._parent_builder

        def lte(self, value: float | None) -> UtteranceFilterBuilder:
            super().lte(value)
            return self._parent_builder

        def in_(self, values: t.Sequence[float | None]) -> UtteranceFilterBuilder:
            super().in_(values)
            return self._parent_builder

        def nin(self, values: t.Sequence[float | None]) -> UtteranceFilterBuilder:
            super().nin(values)
            return self._parent_builder

        def between(self, value1: float | None, value2: float | None) -> UtteranceFilterBuilder:
            super().between(value1, value2)
            return self._parent_builder

        def is_null(self) -> UtteranceFilterBuilder:
            super().is_null()
            return self._parent_builder

        def is_not_null(self) -> UtteranceFilterBuilder:
            super().is_not_null()
            return self._parent_builder

        def asc(self) -> UtteranceFilterBuilder:
            super().asc()
            return self._parent_builder

        def desc(self) -> UtteranceFilterBuilder:
            super().desc()
            return self._parent_builder

    class _StartTimeMsField(FieldFilter[int]):
        """Chainable start_time_ms filter with type-safe operations."""

        def __init__(self, builder: UtteranceFilterBuilder) -> None:
            super().__init__("start_time_ms", object.__getattribute__(builder, "_filter"))
            self._parent_builder = builder

        def eq(self, value: int) -> UtteranceFilterBuilder:
            super().eq(value)
            return self._parent_builder

        def ne(self, value: int) -> UtteranceFilterBuilder:
            super().ne(value)
            return self._parent_builder

        def gt(self, value: int) -> UtteranceFilterBuilder:
            super().gt(value)
            return self._parent_builder

        def lt(self, value: int) -> UtteranceFilterBuilder:
            super().lt(value)
            return self._parent_builder

        def gte(self, value: int) -> UtteranceFilterBuilder:
            super().gte(value)
            return self._parent_builder

        def lte(self, value: int) -> UtteranceFilterBuilder:
            super().lte(value)
            return self._parent_builder

        def in_(self, values: t.Sequence[int]) -> UtteranceFilterBuilder:
            super().in_(values)
            return self._parent_builder

        def nin(self, values: t.Sequence[int]) -> UtteranceFilterBuilder:
            super().nin(values)
            return self._parent_builder

        def between(self, value1: int, value2: int) -> UtteranceFilterBuilder:
            super().between(value1, value2)
            return self._parent_builder

        def is_null(self) -> UtteranceFilterBuilder:
            super().is_null()
            return self._parent_builder

        def is_not_null(self) -> UtteranceFilterBuilder:
            super().is_not_null()
            return self._parent_builder

        def asc(self) -> UtteranceFilterBuilder:
            super().asc()
            return self._parent_builder

        def desc(self) -> UtteranceFilterBuilder:
            super().desc()
            return self._parent_builder

    class _EndTimeMsField(FieldFilter[int]):
        """Chainable end_time_ms filter with type-safe operations."""

        def __init__(self, builder: UtteranceFilterBuilder) -> None:
            super().__init__("end_time_ms", object.__getattribute__(builder, "_filter"))
            self._parent_builder = builder

        def eq(self, value: int) -> UtteranceFilterBuilder:
            super().eq(value)
            return self._parent_builder

        def ne(self, value: int) -> UtteranceFilterBuilder:
            super().ne(value)
            return self._parent_builder

        def gt(self, value: int) -> UtteranceFilterBuilder:
            super().gt(value)
            return self._parent_builder

        def lt(self, value: int) -> UtteranceFilterBuilder:
            super().lt(value)
            return self._parent_builder

        def gte(self, value: int) -> UtteranceFilterBuilder:
            super().gte(value)
            return self._parent_builder

        def lte(self, value: int) -> UtteranceFilterBuilder:
            super().lte(value)
            return self._parent_builder

        def in_(self, values: t.Sequence[int]) -> UtteranceFilterBuilder:
            super().in_(values)
            return self._parent_builder

        def nin(self, values: t.Sequence[int]) -> UtteranceFilterBuilder:
            super().nin(values)
            return self._parent_builder

        def between(self, value1: int, value2: int) -> UtteranceFilterBuilder:
            super().between(value1, value2)
            return self._parent_builder

        def is_null(self) -> UtteranceFilterBuilder:
            super().is_null()
            return self._parent_builder

        def is_not_null(self) -> UtteranceFilterBuilder:
            super().is_not_null()
            return self._parent_builder

        def asc(self) -> UtteranceFilterBuilder:
            super().asc()
            return self._parent_builder

        def desc(self) -> UtteranceFilterBuilder:
            super().desc()
            return self._parent_builder

    class _TimestampField(FieldFilter[datetime.datetime]):
        """Chainable timestamp filter with type-safe operations."""

        def __init__(self, builder: UtteranceFilterBuilder) -> None:
            super().__init__("timestamp", object.__getattribute__(builder, "_filter"))
            self._parent_builder = builder

        def eq(self, value: datetime.datetime) -> UtteranceFilterBuilder:
            super().eq(value)
            return self._parent_builder

        def ne(self, value: datetime.datetime) -> UtteranceFilterBuilder:
            super().ne(value)
            return self._parent_builder

        def gt(self, value: datetime.datetime) -> UtteranceFilterBuilder:
            super().gt(value)
            return self._parent_builder

        def lt(self, value: datetime.datetime) -> UtteranceFilterBuilder:
            super().lt(value)
            return self._parent_builder

        def gte(self, value: datetime.datetime) -> UtteranceFilterBuilder:
            super().gte(value)
            return self._parent_builder

        def lte(self, value: datetime.datetime) -> UtteranceFilterBuilder:
            super().lte(value)
            return self._parent_builder

        def in_(self, values: t.Sequence[datetime.datetime]) -> UtteranceFilterBuilder:
            super().in_(values)
            return self._parent_builder

        def nin(self, values: t.Sequence[datetime.datetime]) -> UtteranceFilterBuilder:
            super().nin(values)
            return self._parent_builder

        def between(
            self, value1: datetime.datetime, value2: datetime.datetime
        ) -> UtteranceFilterBuilder:
            super().between(value1, value2)
            return self._parent_builder

        def is_null(self) -> UtteranceFilterBuilder:
            super().is_null()
            return self._parent_builder

        def is_not_null(self) -> UtteranceFilterBuilder:
            super().is_not_null()
            return self._parent_builder

        def asc(self) -> UtteranceFilterBuilder:
            super().asc()
            return self._parent_builder

        def desc(self) -> UtteranceFilterBuilder:
            super().desc()
            return self._parent_builder

    def and_(self, *filters: Filter) -> Filter:
        """Combine with other filters using AND logic.

        Args:
            *filters: Other filters to combine with AND.

        Returns:
            Combined filter with AND logic.

        Example:
            ```python
            # username = 'john' AND email = 'john@ex.com'
            filter = (
                utterance_filter()
                .username.eq("john")
                .and_(utterance_filter().email.eq("john@ex.com"))
            )
            ```
        """
        return object.__getattribute__(self, "_filter").and_(*filters)

    def or_(self, *filters: Filter) -> Filter:
        """Combine with other filters using OR logic.

        Args:
            *filters: Other filters to combine with OR.

        Returns:
            Combined filter with OR logic.

        Example:
            ```python
            # username = 'john' OR email = 'john@ex.com'
            filter = (
                utterance_filter()
                .username.eq("john")
                .or_(utterance_filter().email.eq("john@ex.com"))
            )
            ```
        """
        return object.__getattribute__(self, "_filter").or_(*filters)

    def not_(self) -> Filter:
        """Negate the current filter.

        Returns:
            Negated filter.

        Example:
            ```python
            # NOT (username = 'john')
            filter = utterance_filter().username.eq("john").not_()
            ```
        """
        return object.__getattribute__(self, "_filter").not_()

    # Field properties

    @property
    def id(self) -> _IdField:
        """Filter by id field."""
        return self._IdField(self)

    @property
    def created_at(self) -> _CreatedAtField:
        """Filter by created_at field."""
        return self._CreatedAtField(self)

    @property
    def updated_at(self) -> _UpdatedAtField:
        """Filter by updated_at field."""
        return self._UpdatedAtField(self)

    @property
    def session_id(self) -> _SessionIdField:
        """Filter by session_id field."""
        return self._SessionIdField(self)

    @property
    def segment_id(self) -> _SegmentIdField:
        """Filter by segment_id field."""
        return self._SegmentIdField(self)

    @property
    def sequence(self) -> _SequenceField:
        """Filter by sequence field."""
        return self._SequenceField(self)

    @property
    def speaker(self) -> _SpeakerField:
        """Filter by speaker field."""
        return self._SpeakerField(self)

    @property
    def text(self) -> _TextField:
        """Filter by text field."""
        return self._TextField(self)

    @property
    def confidence(self) -> _ConfidenceField:
        """Filter by confidence field."""
        return self._ConfidenceField(self)

    @property
    def start_time_ms(self) -> _StartTimeMsField:
        """Filter by start_time_ms field."""
        return self._StartTimeMsField(self)

    @property
    def end_time_ms(self) -> _EndTimeMsField:
        """Filter by end_time_ms field."""
        return self._EndTimeMsField(self)

    @property
    def timestamp(self) -> _TimestampField:
        """Filter by timestamp field."""
        return self._TimestampField(self)


def utterance_filter() -> UtteranceFilterBuilder:
    """Create a Utterance filter builder with full type safety.

    Returns:
        A UtteranceFilterBuilder instance with full IDE support and chainable fields.

    Example:
        ```python
        # AND conditions (chained)
        filter = (
            utterance_filter()
            .field1.eq(value1)
            .field2.contains(value2)
        )

        # OR conditions
        filter = utterance_filter().field1.eq(
            value1
        ) | utterance_filter().field2.eq(value2)
        ```
    """
    return UtteranceFilterBuilder(Utterance)
