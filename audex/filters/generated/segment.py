# This file is auto-generated by PrototypeX filter generator.
# Do not edit manually - changes will be overwritten.
# Regenerate using: python -m scripts.gen_filters gen

from __future__ import annotations

import datetime
import typing as t

from audex.entity.segment import Segment
from audex.filters import FieldFilter
from audex.filters import Filter
from audex.filters import FilterBuilder
from audex.filters import StringFieldFilter


class SegmentFilterBuilder(FilterBuilder[Segment]):
    """Segment filter builder with full type hints and IDE support.

    This class is auto-generated. Do not edit manually.
    """

    class _IdField(StringFieldFilter):
        """Chainable id filter with type-safe operations."""

        def __init__(self, builder: SegmentFilterBuilder) -> None:
            super().__init__("id", object.__getattribute__(builder, "_filter"))
            self._parent_builder = builder

        def eq(self, value: str) -> SegmentFilterBuilder:
            super().eq(value)
            return self._parent_builder

        def ne(self, value: str) -> SegmentFilterBuilder:
            super().ne(value)
            return self._parent_builder

        def gt(self, value: str) -> SegmentFilterBuilder:
            super().gt(value)
            return self._parent_builder

        def lt(self, value: str) -> SegmentFilterBuilder:
            super().lt(value)
            return self._parent_builder

        def gte(self, value: str) -> SegmentFilterBuilder:
            super().gte(value)
            return self._parent_builder

        def lte(self, value: str) -> SegmentFilterBuilder:
            super().lte(value)
            return self._parent_builder

        def in_(self, values: t.Sequence[str]) -> SegmentFilterBuilder:
            super().in_(values)
            return self._parent_builder

        def nin(self, values: t.Sequence[str]) -> SegmentFilterBuilder:
            super().nin(values)
            return self._parent_builder

        def between(self, value1: str, value2: str) -> SegmentFilterBuilder:
            super().between(value1, value2)
            return self._parent_builder

        def is_null(self) -> SegmentFilterBuilder:
            super().is_null()
            return self._parent_builder

        def is_not_null(self) -> SegmentFilterBuilder:
            super().is_not_null()
            return self._parent_builder

        def asc(self) -> SegmentFilterBuilder:
            super().asc()
            return self._parent_builder

        def desc(self) -> SegmentFilterBuilder:
            super().desc()
            return self._parent_builder

        def contains(self, value: str) -> SegmentFilterBuilder:
            super().contains(value)
            return self._parent_builder

        def startswith(self, value: str) -> SegmentFilterBuilder:
            super().startswith(value)
            return self._parent_builder

        def endswith(self, value: str) -> SegmentFilterBuilder:
            super().endswith(value)
            return self._parent_builder

    class _CreatedAtField(FieldFilter[datetime.datetime]):
        """Chainable created_at filter with type-safe operations."""

        def __init__(self, builder: SegmentFilterBuilder) -> None:
            super().__init__("created_at", object.__getattribute__(builder, "_filter"))
            self._parent_builder = builder

        def eq(self, value: datetime.datetime) -> SegmentFilterBuilder:
            super().eq(value)
            return self._parent_builder

        def ne(self, value: datetime.datetime) -> SegmentFilterBuilder:
            super().ne(value)
            return self._parent_builder

        def gt(self, value: datetime.datetime) -> SegmentFilterBuilder:
            super().gt(value)
            return self._parent_builder

        def lt(self, value: datetime.datetime) -> SegmentFilterBuilder:
            super().lt(value)
            return self._parent_builder

        def gte(self, value: datetime.datetime) -> SegmentFilterBuilder:
            super().gte(value)
            return self._parent_builder

        def lte(self, value: datetime.datetime) -> SegmentFilterBuilder:
            super().lte(value)
            return self._parent_builder

        def in_(self, values: t.Sequence[datetime.datetime]) -> SegmentFilterBuilder:
            super().in_(values)
            return self._parent_builder

        def nin(self, values: t.Sequence[datetime.datetime]) -> SegmentFilterBuilder:
            super().nin(values)
            return self._parent_builder

        def between(
            self, value1: datetime.datetime, value2: datetime.datetime
        ) -> SegmentFilterBuilder:
            super().between(value1, value2)
            return self._parent_builder

        def is_null(self) -> SegmentFilterBuilder:
            super().is_null()
            return self._parent_builder

        def is_not_null(self) -> SegmentFilterBuilder:
            super().is_not_null()
            return self._parent_builder

        def asc(self) -> SegmentFilterBuilder:
            super().asc()
            return self._parent_builder

        def desc(self) -> SegmentFilterBuilder:
            super().desc()
            return self._parent_builder

    class _UpdatedAtField(FieldFilter[datetime.datetime | None]):
        """Chainable updated_at filter with type-safe operations."""

        def __init__(self, builder: SegmentFilterBuilder) -> None:
            super().__init__("updated_at", object.__getattribute__(builder, "_filter"))
            self._parent_builder = builder

        def eq(self, value: datetime.datetime | None) -> SegmentFilterBuilder:
            super().eq(value)
            return self._parent_builder

        def ne(self, value: datetime.datetime | None) -> SegmentFilterBuilder:
            super().ne(value)
            return self._parent_builder

        def gt(self, value: datetime.datetime | None) -> SegmentFilterBuilder:
            super().gt(value)
            return self._parent_builder

        def lt(self, value: datetime.datetime | None) -> SegmentFilterBuilder:
            super().lt(value)
            return self._parent_builder

        def gte(self, value: datetime.datetime | None) -> SegmentFilterBuilder:
            super().gte(value)
            return self._parent_builder

        def lte(self, value: datetime.datetime | None) -> SegmentFilterBuilder:
            super().lte(value)
            return self._parent_builder

        def in_(self, values: t.Sequence[datetime.datetime | None]) -> SegmentFilterBuilder:
            super().in_(values)
            return self._parent_builder

        def nin(self, values: t.Sequence[datetime.datetime | None]) -> SegmentFilterBuilder:
            super().nin(values)
            return self._parent_builder

        def between(
            self, value1: datetime.datetime | None, value2: datetime.datetime | None
        ) -> SegmentFilterBuilder:
            super().between(value1, value2)
            return self._parent_builder

        def is_null(self) -> SegmentFilterBuilder:
            super().is_null()
            return self._parent_builder

        def is_not_null(self) -> SegmentFilterBuilder:
            super().is_not_null()
            return self._parent_builder

        def asc(self) -> SegmentFilterBuilder:
            super().asc()
            return self._parent_builder

        def desc(self) -> SegmentFilterBuilder:
            super().desc()
            return self._parent_builder

    class _SessionIdField(StringFieldFilter):
        """Chainable session_id filter with type-safe operations."""

        def __init__(self, builder: SegmentFilterBuilder) -> None:
            super().__init__("session_id", object.__getattribute__(builder, "_filter"))
            self._parent_builder = builder

        def eq(self, value: str) -> SegmentFilterBuilder:
            super().eq(value)
            return self._parent_builder

        def ne(self, value: str) -> SegmentFilterBuilder:
            super().ne(value)
            return self._parent_builder

        def gt(self, value: str) -> SegmentFilterBuilder:
            super().gt(value)
            return self._parent_builder

        def lt(self, value: str) -> SegmentFilterBuilder:
            super().lt(value)
            return self._parent_builder

        def gte(self, value: str) -> SegmentFilterBuilder:
            super().gte(value)
            return self._parent_builder

        def lte(self, value: str) -> SegmentFilterBuilder:
            super().lte(value)
            return self._parent_builder

        def in_(self, values: t.Sequence[str]) -> SegmentFilterBuilder:
            super().in_(values)
            return self._parent_builder

        def nin(self, values: t.Sequence[str]) -> SegmentFilterBuilder:
            super().nin(values)
            return self._parent_builder

        def between(self, value1: str, value2: str) -> SegmentFilterBuilder:
            super().between(value1, value2)
            return self._parent_builder

        def is_null(self) -> SegmentFilterBuilder:
            super().is_null()
            return self._parent_builder

        def is_not_null(self) -> SegmentFilterBuilder:
            super().is_not_null()
            return self._parent_builder

        def asc(self) -> SegmentFilterBuilder:
            super().asc()
            return self._parent_builder

        def desc(self) -> SegmentFilterBuilder:
            super().desc()
            return self._parent_builder

        def contains(self, value: str) -> SegmentFilterBuilder:
            super().contains(value)
            return self._parent_builder

        def startswith(self, value: str) -> SegmentFilterBuilder:
            super().startswith(value)
            return self._parent_builder

        def endswith(self, value: str) -> SegmentFilterBuilder:
            super().endswith(value)
            return self._parent_builder

    class _SequenceField(FieldFilter[int]):
        """Chainable sequence filter with type-safe operations."""

        def __init__(self, builder: SegmentFilterBuilder) -> None:
            super().__init__("sequence", object.__getattribute__(builder, "_filter"))
            self._parent_builder = builder

        def eq(self, value: int) -> SegmentFilterBuilder:
            super().eq(value)
            return self._parent_builder

        def ne(self, value: int) -> SegmentFilterBuilder:
            super().ne(value)
            return self._parent_builder

        def gt(self, value: int) -> SegmentFilterBuilder:
            super().gt(value)
            return self._parent_builder

        def lt(self, value: int) -> SegmentFilterBuilder:
            super().lt(value)
            return self._parent_builder

        def gte(self, value: int) -> SegmentFilterBuilder:
            super().gte(value)
            return self._parent_builder

        def lte(self, value: int) -> SegmentFilterBuilder:
            super().lte(value)
            return self._parent_builder

        def in_(self, values: t.Sequence[int]) -> SegmentFilterBuilder:
            super().in_(values)
            return self._parent_builder

        def nin(self, values: t.Sequence[int]) -> SegmentFilterBuilder:
            super().nin(values)
            return self._parent_builder

        def between(self, value1: int, value2: int) -> SegmentFilterBuilder:
            super().between(value1, value2)
            return self._parent_builder

        def is_null(self) -> SegmentFilterBuilder:
            super().is_null()
            return self._parent_builder

        def is_not_null(self) -> SegmentFilterBuilder:
            super().is_not_null()
            return self._parent_builder

        def asc(self) -> SegmentFilterBuilder:
            super().asc()
            return self._parent_builder

        def desc(self) -> SegmentFilterBuilder:
            super().desc()
            return self._parent_builder

    class _AudioKeyField(StringFieldFilter):
        """Chainable audio_key filter with type-safe operations."""

        def __init__(self, builder: SegmentFilterBuilder) -> None:
            super().__init__("audio_key", object.__getattribute__(builder, "_filter"))
            self._parent_builder = builder

        def eq(self, value: str) -> SegmentFilterBuilder:
            super().eq(value)
            return self._parent_builder

        def ne(self, value: str) -> SegmentFilterBuilder:
            super().ne(value)
            return self._parent_builder

        def gt(self, value: str) -> SegmentFilterBuilder:
            super().gt(value)
            return self._parent_builder

        def lt(self, value: str) -> SegmentFilterBuilder:
            super().lt(value)
            return self._parent_builder

        def gte(self, value: str) -> SegmentFilterBuilder:
            super().gte(value)
            return self._parent_builder

        def lte(self, value: str) -> SegmentFilterBuilder:
            super().lte(value)
            return self._parent_builder

        def in_(self, values: t.Sequence[str]) -> SegmentFilterBuilder:
            super().in_(values)
            return self._parent_builder

        def nin(self, values: t.Sequence[str]) -> SegmentFilterBuilder:
            super().nin(values)
            return self._parent_builder

        def between(self, value1: str, value2: str) -> SegmentFilterBuilder:
            super().between(value1, value2)
            return self._parent_builder

        def is_null(self) -> SegmentFilterBuilder:
            super().is_null()
            return self._parent_builder

        def is_not_null(self) -> SegmentFilterBuilder:
            super().is_not_null()
            return self._parent_builder

        def asc(self) -> SegmentFilterBuilder:
            super().asc()
            return self._parent_builder

        def desc(self) -> SegmentFilterBuilder:
            super().desc()
            return self._parent_builder

        def contains(self, value: str) -> SegmentFilterBuilder:
            super().contains(value)
            return self._parent_builder

        def startswith(self, value: str) -> SegmentFilterBuilder:
            super().startswith(value)
            return self._parent_builder

        def endswith(self, value: str) -> SegmentFilterBuilder:
            super().endswith(value)
            return self._parent_builder

    class _StartedAtField(FieldFilter[datetime.datetime]):
        """Chainable started_at filter with type-safe operations."""

        def __init__(self, builder: SegmentFilterBuilder) -> None:
            super().__init__("started_at", object.__getattribute__(builder, "_filter"))
            self._parent_builder = builder

        def eq(self, value: datetime.datetime) -> SegmentFilterBuilder:
            super().eq(value)
            return self._parent_builder

        def ne(self, value: datetime.datetime) -> SegmentFilterBuilder:
            super().ne(value)
            return self._parent_builder

        def gt(self, value: datetime.datetime) -> SegmentFilterBuilder:
            super().gt(value)
            return self._parent_builder

        def lt(self, value: datetime.datetime) -> SegmentFilterBuilder:
            super().lt(value)
            return self._parent_builder

        def gte(self, value: datetime.datetime) -> SegmentFilterBuilder:
            super().gte(value)
            return self._parent_builder

        def lte(self, value: datetime.datetime) -> SegmentFilterBuilder:
            super().lte(value)
            return self._parent_builder

        def in_(self, values: t.Sequence[datetime.datetime]) -> SegmentFilterBuilder:
            super().in_(values)
            return self._parent_builder

        def nin(self, values: t.Sequence[datetime.datetime]) -> SegmentFilterBuilder:
            super().nin(values)
            return self._parent_builder

        def between(
            self, value1: datetime.datetime, value2: datetime.datetime
        ) -> SegmentFilterBuilder:
            super().between(value1, value2)
            return self._parent_builder

        def is_null(self) -> SegmentFilterBuilder:
            super().is_null()
            return self._parent_builder

        def is_not_null(self) -> SegmentFilterBuilder:
            super().is_not_null()
            return self._parent_builder

        def asc(self) -> SegmentFilterBuilder:
            super().asc()
            return self._parent_builder

        def desc(self) -> SegmentFilterBuilder:
            super().desc()
            return self._parent_builder

    class _EndedAtField(FieldFilter[datetime.datetime | None]):
        """Chainable ended_at filter with type-safe operations."""

        def __init__(self, builder: SegmentFilterBuilder) -> None:
            super().__init__("ended_at", object.__getattribute__(builder, "_filter"))
            self._parent_builder = builder

        def eq(self, value: datetime.datetime | None) -> SegmentFilterBuilder:
            super().eq(value)
            return self._parent_builder

        def ne(self, value: datetime.datetime | None) -> SegmentFilterBuilder:
            super().ne(value)
            return self._parent_builder

        def gt(self, value: datetime.datetime | None) -> SegmentFilterBuilder:
            super().gt(value)
            return self._parent_builder

        def lt(self, value: datetime.datetime | None) -> SegmentFilterBuilder:
            super().lt(value)
            return self._parent_builder

        def gte(self, value: datetime.datetime | None) -> SegmentFilterBuilder:
            super().gte(value)
            return self._parent_builder

        def lte(self, value: datetime.datetime | None) -> SegmentFilterBuilder:
            super().lte(value)
            return self._parent_builder

        def in_(self, values: t.Sequence[datetime.datetime | None]) -> SegmentFilterBuilder:
            super().in_(values)
            return self._parent_builder

        def nin(self, values: t.Sequence[datetime.datetime | None]) -> SegmentFilterBuilder:
            super().nin(values)
            return self._parent_builder

        def between(
            self, value1: datetime.datetime | None, value2: datetime.datetime | None
        ) -> SegmentFilterBuilder:
            super().between(value1, value2)
            return self._parent_builder

        def is_null(self) -> SegmentFilterBuilder:
            super().is_null()
            return self._parent_builder

        def is_not_null(self) -> SegmentFilterBuilder:
            super().is_not_null()
            return self._parent_builder

        def asc(self) -> SegmentFilterBuilder:
            super().asc()
            return self._parent_builder

        def desc(self) -> SegmentFilterBuilder:
            super().desc()
            return self._parent_builder

    class _DurationMsField(FieldFilter[int | None]):
        """Chainable duration_ms filter with type-safe operations."""

        def __init__(self, builder: SegmentFilterBuilder) -> None:
            super().__init__("duration_ms", object.__getattribute__(builder, "_filter"))
            self._parent_builder = builder

        def eq(self, value: int | None) -> SegmentFilterBuilder:
            super().eq(value)
            return self._parent_builder

        def ne(self, value: int | None) -> SegmentFilterBuilder:
            super().ne(value)
            return self._parent_builder

        def gt(self, value: int | None) -> SegmentFilterBuilder:
            super().gt(value)
            return self._parent_builder

        def lt(self, value: int | None) -> SegmentFilterBuilder:
            super().lt(value)
            return self._parent_builder

        def gte(self, value: int | None) -> SegmentFilterBuilder:
            super().gte(value)
            return self._parent_builder

        def lte(self, value: int | None) -> SegmentFilterBuilder:
            super().lte(value)
            return self._parent_builder

        def in_(self, values: t.Sequence[int | None]) -> SegmentFilterBuilder:
            super().in_(values)
            return self._parent_builder

        def nin(self, values: t.Sequence[int | None]) -> SegmentFilterBuilder:
            super().nin(values)
            return self._parent_builder

        def between(self, value1: int | None, value2: int | None) -> SegmentFilterBuilder:
            super().between(value1, value2)
            return self._parent_builder

        def is_null(self) -> SegmentFilterBuilder:
            super().is_null()
            return self._parent_builder

        def is_not_null(self) -> SegmentFilterBuilder:
            super().is_not_null()
            return self._parent_builder

        def asc(self) -> SegmentFilterBuilder:
            super().asc()
            return self._parent_builder

        def desc(self) -> SegmentFilterBuilder:
            super().desc()
            return self._parent_builder

    def and_(self, *filters: Filter) -> Filter:
        """Combine with other filters using AND logic.

        Args:
            *filters: Other filters to combine with AND.

        Returns:
            Combined filter with AND logic.

        Example:
            ```python
            # username = 'john' AND email = 'john@ex.com'
            filter = (
                segment_filter()
                .username.eq("john")
                .and_(segment_filter().email.eq("john@ex.com"))
            )
            ```
        """
        return object.__getattribute__(self, "_filter").and_(*filters)

    def or_(self, *filters: Filter) -> Filter:
        """Combine with other filters using OR logic.

        Args:
            *filters: Other filters to combine with OR.

        Returns:
            Combined filter with OR logic.

        Example:
            ```python
            # username = 'john' OR email = 'john@ex.com'
            filter = (
                segment_filter()
                .username.eq("john")
                .or_(segment_filter().email.eq("john@ex.com"))
            )
            ```
        """
        return object.__getattribute__(self, "_filter").or_(*filters)

    def not_(self) -> Filter:
        """Negate the current filter.

        Returns:
            Negated filter.

        Example:
            ```python
            # NOT (username = 'john')
            filter = segment_filter().username.eq("john").not_()
            ```
        """
        return object.__getattribute__(self, "_filter").not_()

    # Field properties

    @property
    def id(self) -> _IdField:
        """Filter by id field."""
        return self._IdField(self)

    @property
    def created_at(self) -> _CreatedAtField:
        """Filter by created_at field."""
        return self._CreatedAtField(self)

    @property
    def updated_at(self) -> _UpdatedAtField:
        """Filter by updated_at field."""
        return self._UpdatedAtField(self)

    @property
    def session_id(self) -> _SessionIdField:
        """Filter by session_id field."""
        return self._SessionIdField(self)

    @property
    def sequence(self) -> _SequenceField:
        """Filter by sequence field."""
        return self._SequenceField(self)

    @property
    def audio_key(self) -> _AudioKeyField:
        """Filter by audio_key field."""
        return self._AudioKeyField(self)

    @property
    def started_at(self) -> _StartedAtField:
        """Filter by started_at field."""
        return self._StartedAtField(self)

    @property
    def ended_at(self) -> _EndedAtField:
        """Filter by ended_at field."""
        return self._EndedAtField(self)

    @property
    def duration_ms(self) -> _DurationMsField:
        """Filter by duration_ms field."""
        return self._DurationMsField(self)


def segment_filter() -> SegmentFilterBuilder:
    """Create a Segment filter builder with full type safety.

    Returns:
        A SegmentFilterBuilder instance with full IDE support and chainable fields.

    Example:
        ```python
        # AND conditions (chained)
        filter = (
            segment_filter()
            .field1.eq(value1)
            .field2.contains(value2)
        )

        # OR conditions
        filter = segment_filter().field1.eq(
            value1
        ) | segment_filter().field2.eq(value2)
        ```
    """
    return SegmentFilterBuilder(Segment)
